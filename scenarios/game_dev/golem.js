window.SCENARIOS['golem'] = {
    meta: {
      title: "BP_GuardianGolem is Non-Functional: Full Debug Hunt",
      description:
        "Critical enemy asset fails to spawn, T-poses, leaks VFX memory, and breaks on the network.",
      estimateHours: 14.0,
        difficulty: "Advanced",
        category: "AI" // Adjusted for increased debugging complexity and dead ends
    },
    start: "step-1",
    steps:
      {
        // === 1. COMPILATION & CLASS ABSTRACTION ISSUES ===
        'step-1': {
          skill:'compile',
          title:'Abstract Class Error',
          prompt:"<p>You try to place <code>BP_GuardianGolem</code> in the level, but nothing happens. The <strong>Output Log</strong> shows: <code>Error: Could not create actor... The class is abstract and must be subclassed.</code></p><strong>What is the cause of this abstract class error in Blueprints?</strong>",
          choices:[
            {text:"Implement the required unimplemented function inherited from the parent C++ class.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The Blueprint is abstract because it inherits an unimplemented event, often marked with an error in the My Blueprint panel.</p>",next:'step-2'},
            {text:'Delete the asset and re-create it, hoping the corruption clears.',type:'wrong',feedback:"<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This is a destructive action that won't solve the root inheritance problem.</p>",next:'step-1W'},
            {text:'Check the Blueprint's variables for an unchecked <code>Expose on Spawn</code> property.',type:'misguided',feedback:"<p><strong>Extended Time Logged (Investigation):</strong> <code>Expose on Spawn</code> is related to spawning but does not make a class abstract. This fix is misguided and wastes time.</p>",next:'step-1M'},
            {text:'Recompile the parent C++ code without making any changes.',type:'partial',feedback:"<p><strong>Standard Time Logged:</strong> This is an indirect approach. You need to investigate the inherited functions.</p>",next:'step-3'}
          ]
        },
        
        'step-1W': {skill:'compile',title:'Asset Deletion Wastes Time',prompt:"<p>Deleting and recreating the asset failed to fix the error because the problem is inherited from the parent class. You must now find the function.</p><strong>How do you find the unimplemented function?</strong>",choices:[{text:'In the My Blueprint panel, right-click the parent function name and select 'Implement function'.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Re-focusing on the correct workflow. The editor guides you to implement required functions.</p>",next:'step-3'},{text:'Open the parent C++ class and remove the 'BlueprintImplementableEvent' tag.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Dangerous code change that breaks the game systems relying on this event.</p>",next:'step-3'}]},
        
        'step-1M': {skill:'compile',title:'Misguided Variable Check Failure',prompt:"<p>Checking the <code>Expose on Spawn</code> property did not resolve the abstract class error. This property only affects variables passed during the <code>Spawn Actor</code> node and is not the cause of an abstract class definition.</p><strong>You realize this was a dead end. What should you do next to address the abstract class error?</strong>",choices:[{text:'Go back and investigate the inherited functions in the My Blueprint panel.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Returning to the correct path, you realize the error is caused by an unimplemented inherited function.</p>",next:'step-3'},{text:'Try recompiling the parent C++ code again (Partial answer from Step 1).',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> You are still avoiding the direct investigation, wasting more time on indirect fixes.</p>",next:'step-3'}]},

        // === 2. ANIMATION & DATA FLOW ISSUES ===
        'step-2': {skill:'anim',title:'The Runtime T-Pose',prompt:"<p>The Golem now spawns, but is stuck in a T-Pose. The AnimBP preview is working, but the in-game character is frozen.</p><strong>Where is the most likely data disconnect preventing animation playback?</strong>",choices:[{text:'Trace the AnimBP's Event Graph logic to ensure data variables (like Speed) are being updated from the main Golem Blueprint (Cast failure).',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The <code>AnimBP</code> is a separate machine that relies on data from the character. If the <code>Cast</code> fails, the <code>State Machine</code> defaults to its entry pose (T-Pose).</p>",next:'step-3'},{text:'Change the Skeletal Mesh Component's 'Animation Mode' to 'Use Animation Asset'.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This would play a single animation, not result in a T-Pose, suggesting the <code>AnimBP</code> is assigned but not driven.</p>",next:'step-3'},{text:'Reimport the Skeletal Mesh and all associated animations.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The preview works, confirming the asset is fine. The problem is runtime logic.</p>",next:'step-2W'},{text:'Check if the character's physics asset is blocking movement.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> You think this is a physics issue and check the Golem's Physics Asset.</p>",next:'step-2M'}]},
        
        // Dead-end: Mistaking T-pose for asset corruption
        'step-2W': {skill:'anim',title:'Asset Reimport Was Useless',prompt:"<p>You wasted maximum time re-importing the Golem mesh and animations. The issue persists. Since the animation preview works, the issue is clearly runtime logic, not asset corruption.</p><strong>Where must the core data flow failure lie?</strong>",choices:[{text:'Check the data casting between the AnimBP and the main Golem Blueprint.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> You correctly refocused on the AnimBP's dependency on the Golem's runtime data.</p>",next:'step-3'},{text:'Check the Golem's <code>Movement Mode</code>, maybe it's set to <code>None</code>.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is an unrelated fix. Movement mode doesn't affect the AnimBP ticking logic.</p>",next:'step-3'}]},

        // Dead-end: Mistaking T-pose for physics issues
        'step-2M': {skill:'anim',title:'Physics Asset Investigation (Dead End)',prompt:"<p>You spent extended time reviewing and simplifying the Golem's <code>Physics Asset</code>. While optimization is good, it had no effect on the T-pose because the character's animation system runs separately from the physics simulation.</p><strong>You realize the problem must be in the AnimBP's initialization. What is the next step?</strong>",choices:[{text:'Check the data casting between the AnimBP and the main Golem Blueprint.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Correctly identifying the AnimBP's dependency on character data as the root cause.</p>",next:'step-3'},{text:'Check if the Golem's <code>Skeletal Mesh Component</code> is set to <code>Visible</code>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The Golem is visible, just T-posing. This is an obviously wrong check.</p>",next:'step-3'}]},
        
        'step-3': {skill:'anim',title:'Tracing the Data Flow Failure',prompt:"<p>You find the AnimBP's <code>Cast to BP_GuardianGolem</code> node fails immediately on <code>Event Blueprint Update Animation</code> due to a timing issue.</p><strong>What is the standard, robust pattern to fix this AnimBP casting failure?</strong>",choices:[{text:'Use <code>Event Blueprint Initialize Animation</code> to establish a solid reference to the Golem once, avoiding the per-frame cast and potential timing issues.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Initializing the reference once at the correct time is far more efficient than casting every frame on Update Animation.</p>",next:'step-4'},{text:'Add an <code>IsValid</code> check after the Cast. Only update variables if the Cast succeeds.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This prevents crashes but causes a jarring pop-in (visual technical debt) as the character T-poses until the Cast succeeds.</p>",next:'step-4'},{text:'Add a 0.2 second Delay before the Cast to ensure the character is fully possessed.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is a brittle, 'magic number' fix prone to failing on different machine speeds or during hitches.</p>",next:'step-4'},{text:'Move the Cast logic to the Golem Blueprint and send the data back to the AnimBP via a variable binding.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This inverts the data flow complexity and doesn't solve the core timing issue.</p>",next:'step-4'}]},
        'step-4': {skill:'anim',title:'The T-Pose Visual Tech Debt',prompt:"<p>You choose the <strong>Partial</strong> answer (the <code>IsValid</code> check). The Golem animates, but QA reports the Golem 'snaps' from a T-pose when it first spawns. The lead asks you to move on, but you know this is bad practice.</p><strong>What do you call the best practice pattern you should have used?</strong>",choices:[{text:'The robust, event-driven reference initialization pattern (using <code>Initialize Animation</code>).',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Acknowledging the tech debt and remembering the best practice. This is the correct soft skill.</p>",next:'step-5'},{text:'The <code>Character Movement Component</code> has its <code>Default Land Movement Mode</code> set to None.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Unrelated to the animation initialization issue.</p>",next:'step-5'},{text:'The AnimBP is overriding the wrong function, it should use <code>Post Update Animation</code>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> <code>Update Animation</code> is the correct place to update variables.</p>",next:'step-5'},{text:'The delay node was still the better solution for reliability.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Still believing in the fragile delay solution shows a lack of understanding of event-driven reliability.</p>",next:'step-5'}]},
        
        // === 3. VFX, SOUND, & ACTOR LIFECYCLE ISSUES ===
        'step-5': {skill:'vfx',title:'The Missing Anim Notify',prompt:"<p>The Golem animates, but a crucial ground-shatter VFX is missing during the Slam Attack. The VFX is triggered by an <code>Anim Notify</code> called <code>FX_SlamImpact</code>.</p><strong>What is your primary check when debugging a failing Anim Notify?</strong>",choices:[{text:'Open the Animation Sequence (A_Golem_Slam) and verify the <code>FX_SlamImpact</code> notify exists on the <code>Notify Track</code> and is correctly placed/spelled.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The <code>Anim Notify</code> asset and its timeline placement are the source. Missing or misspelled notifies are the most common cause.</p>",next:'step-6'},{text:'Place a breakpoint on the corresponding event in the AnimBP's <code>Event Graph</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is a good second step, but if the notify is missing from the timeline, the breakpoint will never be hit, wasting time tracing the wrong component.</p>",next:'step-6'},{text:'Check the <code>Niagara System</code> asset to ensure it is not compiled with errors.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> You have no evidence the <code>Niagara System</code> is the problem yet; the issue points to the trigger mechanism.</p>",next:'step-6'},{text:'Change the notify's timing in the Montage instead of the <code>Anim Sequence</code>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> <code>Anim Notifies</code> are placed on the base sequence, not the montage layer.</p>",next:'step-6'}]},
        'step-6': {skill:'vfx',title:'The Emitter Spawns at Origin',prompt:"<p>You fix a typo in the <code>Anim Notify</code> name, and the VFX plays, but it always spawns at the world origin (0,0,0) instead of under the Golem's foot.</p><strong>How do you fix the VFX spawn location?</strong>",choices:[{text:'Use <code>Spawn Emitter Attached</code> and provide the Golem's mesh and a foot socket name as the attach point.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Attaching ensures the effect tracks the skeletal mesh, using relative transforms for the most accurate and robust positioning.</p>",next:'step-7'},{text:'Use <code>Get Socket Location</code> on the mesh and feed that world location into <code>Spawn Emitter at Location</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This works, but is less robust. If the Golem moves rapidly, the location could be slightly off before the next tick updates the position.</p>",next:'step-7'},{text:'Manually add the Golem's world location to a hard-coded offset vector.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Brittle fix that breaks if the Golem's location or rotation changes dramatically.</p>",next:'step-7'},{text:'The <code>Niagara System</code> needs its <code>Local Space</code> flag enabled.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> You are attempting to fix the world-space location with a local-space particle setting.</p>",next:'step-6W'}]},
        
        // Dead-end: Mismatching world vs local space settings for spawn
        'step-6W': {skill:'vfx',title:'Local Space Confusion (Dead End)',prompt:"<p>You tried enabling <code>Local Space</code> in the <code>Niagara System</code>, but it had no effect on the emitter's spawn location. <code>Local Space</code> only controls whether the particles move with the emitter's parent. The issue is where the emitter's *container* is spawned in the world.</p><strong>What is the correct way to handle spatial relationships for spawning emitters?</strong>",choices:[{text:'Use <code>Spawn Emitter Attached</code> and provide the Golem's mesh and a socket name as the attach point.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The correct approach is always to attach the emitter to the skeletal mesh for reliable tracking.</p>",next:'step-7'},{text:'Set the <code>Spawn Emitter at Location</code> node to use the character's world <code>Root Component</code> location.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is a step up, but it still lacks the precision of a dedicated foot socket.</p>",next:'step-7'}]},

        'step-7': {skill:'vfx',title:'Leaking VFX Actors',prompt:"<p>The VFX plays correctly, but after a few attacks, the frame rate dips. <code>obj list class=NiagaraActor</code> shows hundreds of <code>Niagara actors</code> still in memory.</p><strong>What is causing this memory leak?</strong>",choices:[{text:'Check the <code>Spawn Emitter Attached</code> node to ensure the <code>Auto Destroy</code> checkbox is checked.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The actor container must explicitly be marked for destruction via <code>Auto Destroy</code> or a manual <code>Destroy Actor</code> node after the effect is complete.</p>",next:'step-8'},{text:'Manually call <code>Destroy Actor</code> on the emitter reference after a Delay node matching the effect's duration.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This achieves cleanup but is less efficient and more error-prone than using the built-in <code>Auto Destroy</code> flag.</p>",next:'step-8'},{text:'Reduce the particle count in the <code>Niagara System</code> to lessen memory pressure.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This addresses symptoms but not the root cause (actor lifecycle management).</p>",next:'step-8'},{text:'Wait for the <code>Garbage Collector</code> to run; it will eventually clean up unused actors.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The <code>Garbage Collector</code> only cleans up unreferenced memory, not actors that are still referenced or not explicitly marked for destruction.</p>",next:'step-8'}]},
        
        // === 4. MATERIAL & RENDERING OPTIMIZATION ISSUES ===
        'step-8': {skill:'material',title:'Unlit Gray VFX',prompt:"<p>The memory leak is fixed, but the VFX looks flat, gray, and unlit instead of a fiery explosion. The Material uses a <code>Particle Color</code> node multiplied by a texture, but the result is black (0,0,0).</p><strong>What is the best fix to correctly drive the Material?</strong>",choices:[{text:'In the Niagara emitter, add or adjust the <code>Scale Color</code> module to output the necessary color data for the Material to use.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The Material expects particle color data, but the <code>Niagara system</code> wasn't providing it. Fix the data flow from the particle system to the shader.</p>",next:'step-9'},{text:'Delete the <code>Particle Color</code> node and connect the texture directly to the material's <code>Emissive</code> output.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This makes it visible but removes particle system control (fading/lifetime color changes), breaking the intended look.</p>",next:'step-9'},{text:'Change the material's <code>Blend Mode</code> from Opaque to Additive.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This changes the blend, but doesn't fix the unlit black result, and risks severe overdraw.</p>",next:'step-9'},{text:'Reimport the texture files used by the material.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The black output is a logical flaw in the shader graph/data flow, not a texture import error.</p>",next:'step-9'}]},
        'step-9': {skill:'perf',title:'Overdraw Crisis (Visual Tech Debt)',prompt:"<p>You chose the <strong>Partial</strong> answer (deleting the <code>Particle Color</code> node). The VFX is now visible, but it looks terrible and performance dips because the material is set to <strong>Translucent</strong>.</p><strong>What optimization should you perform immediately to resolve the Translucent/Overdraw issue?</strong>",choices:[{text:'Change the material's <code>Blend Mode</code> from <code>Translucent</code> to a more performant option like <code>Additive</code> or <code>Masked</code>.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>Translucency</code> is extremely costly when multiple particles overlap. Changing the blend mode fixes the overdraw issue.</p>",next:'step-10'},{text:'Reduce the size of the particle sprites in the <code>Niagara system</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Reduces the severity of overdraw but doesn't fix the fundamental performance cost of the <code>Translucent</code> blend mode.</p>",next:'step-10'},{text:'Enable the <code>Use Ray Tracing</code> flag on the material.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> <code>Ray Tracing</code> is a high-end feature that adds significant cost; it will not fix the overdraw issue.</p>",next:'step-10'},{text:'Wait for the rendering team to provide a better shader.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Blaming another team for a basic setup error is not a solution.</p>",next:'step-10'}]},
        'step-10': {skill:'perf',title:'The Draw Call Spike (Mass Placement)',prompt:"<p>The lead places 50 Golems in the level for a stress test. The frame rate drops significantly, and the profiler flags <code>Draw Calls</code> and the <code>Render Thread</code> as the bottleneck.</p><strong>What common material setup is most likely causing excessive draw calls across all Golems?</strong>",choices:[{text:'Check if the Golem's eye glow or another feature is generating a unique <code>Dynamic Material Instance (DMI)</code> per Golem, thus breaking instancing.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>DMIs</code> force unique <code>draw calls</code>, which is the classic cause of a <code>draw call spike</code> when actors should be instanced.</p>",next:'step-11'},{text:'The VFX material is still causing complexity issues.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Complexity affects shader time, not <code>draw call</code> count. You misidentified the bottleneck, but the area of investigation is material related.</p>",next:'step-11'},{text:'The Golem <code>Skeletal Mesh</code> has too many material slots (<code>sub-meshes</code>).',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This fix is misguided as the issue is DMI instantiation, not sub-mesh count.</p>",next:'step-10M'},{text:'The <code>Tick</code> function is too heavy, starving the <code>Render Thread</code>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The profiler points specifically to the <code>Render Thread</code>'s <code>draw call</code> cost, not the <code>Game Thread</code>'s <code>Tick</code> cost.</p>",next:'step-11'}]},
        
        // Dead-end: Mesh optimization doesn't fix instancing break
        'step-10M': {skill:'perf',title:'Merging Mesh Slots (Dead End)',prompt:"<p>You spent extended time optimizing the Golem mesh by combining its material slots (sub-meshes). While this reduced the base draw calls per Golem from 3 to 2, the <strong>draw call spike</strong> on the <code>Render Thread</code> persists when 50 Golems are placed.</p><strong>You realize the problem is still related to the material's instance parameters. What is the root cause?</strong>",choices:[{text:'The eye glow is generating a unique <code>Dynamic Material Instance (DMI)</code> per Golem, thus breaking instancing.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Correctly identifying the DMI as the sole cause of the draw call spike.</p>",next:'step-11'},{text:'The mesh is using <code>World Position Offset</code>, which prevents instancing.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> <code>WPO</code> can be instanced if not using per-instance parameters. This is a common confusion point.</p>",next:'step-11'}]},

        'step-11': {skill:'material',title:'The DMI Refactor',prompt:"<p>You confirm the Golem's eye material uses a <code>Dynamic Material Instance (DMI)</code> to drive the 'Enraged Glow' color per instance.</p><strong>What is the best alternative to <code>DMIs</code> for performant, instance-specific material parameters?</strong>",choices:[{text:'Refactor the eye material to use a <code>Material Parameter Collection (MPC)</code>, which is a global data asset that can be updated in a single render pass.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>MPCs</code> are the standard solution for globally synchronized material changes that don't break instancing, saving hundreds of <code>draw calls</code>.</p>",next:'step-12'},{text:'Use a <code>Per-Instance Custom Data</code> node in the material, driven by C++ code.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Highly performant, but <code>MPCs</code> are generally easier to implement in <code>Blueprint-heavy</code> projects.</p>",next:'step-12'},{text:'Remove the <code>DMI</code> and simplify the material until it no longer needs instance-specific parameters.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This forces an unnecessary design change; the requirement is to *keep* the per-instance glow but make it performant.</p>",next:'step-12'},{text:'Set the material to <code>Unlit</code>, as <code>unlit</code> materials are inherently faster to draw.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The lit/unlit state does not affect whether the renderer can instance the material.</p>",next:'step-12'}]},
        'step-12': {skill:'material',title:'MPC Naming Conflict',prompt:"<p>You implement the <code>MPC</code> glow, but when you test, the Golem's eyes are always the wrong color (e.g., green) regardless of the Golem's state.</p><strong>What is the most likely cause of your <code>MPC</code> value being ignored or overwritten?</strong>",choices:[{text:'Another system in the level is also writing to the same <code>MPC</code> parameter every frame, causing a <code>naming collision</code> and overwriting your value.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> This is a classic 'battle of the systems' bug since <code>MPCs</code> are global. Parameter names must be unique to the feature.</p>",next:'step-13'},{text:'The Material assigned to the eye doesn't actually reference the <code>MPC</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Plausible, but the eye color would likely be default (black), not a specific wrong color like green.</p>",next:'step-13'},{text:'The Golem Blueprint is setting the <code>MPC</code> value on <code>Event BeginPlay</code>, which is too early.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Timing is less of an issue here than the constant frame-by-frame overwrite.</p>",next:'step-13'},{text:'You must call <code>Apply Changes</code> after setting an <code>MPC</code> value.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> No such node exists; the update is immediate.</p>",next:'step-13'}]},
        
        // === 5. NETWORKING & REPLICATION ISSUES ===
        'step-13': {skill:'rep',title:'Multilayer Glow Failure',prompt:"<p>You rename your <code>MPC</code> parameter, and the glow works in single-player. But in multiplayer, client Golems don't glow when enraged. The server Golem glows correctly.</p><strong>What is the standard, efficient fix for replicating cosmetic state changes like the eye color?</strong>",choices:[{text:'Change the <code>IsEnraged</code> boolean variable's replication type to <code>RepNotify</code> and place the visual update logic in the generated <code>OnRep_IsEnraged</code> function.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>RepNotify</code> is efficient, event-driven, and correctly handles late joiners by ensuring the visual update runs reliably on clients when the variable state changes.</p>",next:'step-14'},{text:'Create a <code>Multicast RPC</code> that runs the visual update logic on all clients whenever the state changes.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> A <code>Multicast</code> works for existing clients but fails for late joiners, who will never receive the <code>RPC</code>, causing desync.</p>",next:'step-14'},{text:'Run the visual update logic on the client's <code>Event Tick</code>, checking for the server-replicated variable change.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Polling on <code>Tick</code> is highly inefficient, wasting CPU cycles checking a state that changes infrequently.</p>",next:'step-14'},{text:'Enable the 'Replicates' flag on the <code>Material Parameter Collection</code> asset itself.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Data assets do not replicate; only actors and their properties do.</p>",next:'step-14'}]},
        'step-14': {skill:'rep',title:'Multilayer Animation Desync',prompt:"<p>The glow replicates. However, when the Golem attacks, the server Golem plays the slam montage perfectly, but client Golems slide without the animation.</p><strong>How must the montage playback be replicated to clients?</strong>",choices:[{text:'Place the <code>Play Anim Montage</code> node inside a reliable <code>Multicast RPC</code>, ensuring all clients are explicitly told to run the cosmetic animation.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> One-shot cosmetic events (like Montages or <code>VFX playback</code>) must be explicitly <code>Multicast</code> to all clients, as they are not automatically replicated with movement.</p>",next:'step-15'},{text:'Change the <code>montage trigger variable</code> to a <code>RepNotify</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is an indirect way that adds unnecessary state management complexity when a direct <code>Multicast RPC</code> is the cleaner pattern for one-shot events.</p>",next:'step-15'},{text:'Increase the replication rate settings on the Golem's <code>Skeletal Mesh Component</code>.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Increasing the rate helps smooth movement but does not resolve the logical issue that the engine was never told to play the animation on the client.</p>",next:'step-15'},{text:'Set the <code>Anim Montage</code> asset's 'Replicate' property to true.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> <code>Anim Montage</code> assets do not have a simple replication flag.</p>",next:'step-15'}]},
        'step-15': {skill:'rep',title:'Input Lockout Bug',prompt:"<p>After being attacked by the Golem, players sometimes lose the ability to jump or use their secondary attack. Their primary attack still works.</p><strong>What is the most likely cause of this partial input lockout?</strong>",choices:[{text:'A logic path is enabling a <code>Gameplay Ability</code> input or setting a <code>Gameplay Tag</code> on the character, but the corresponding disabling logic is failing to run.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>Partial lockouts</code> are almost always tied to <code>Gameplay Tags</code> or the <code>Ability System</code> failing to remove an active state that is blocking specific input bindings.</p>",next:'step-16'},{text:'The <code>character movement component</code> is disabled, preventing only movement-related inputs.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> The primary attack works, so the <code>movement component</code> isn't the primary cause. The problem is selective input processing.</p>",next:'step-16'},{text:'The <code>player controller</code> is losing its input focus (<code>Unpossessed</code>).',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> If <code>unpossessed</code>, the player would lose all input, including primary attack.</p>",next:'step-16'},{text:'The <code>input mapping context</code> is corrupted.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Corruption would cause a persistent, non-conditional failure.</p>",next:'step-16'}]},
        
        // === 6. FINAL CLEANUP & BUILD ISSUES ===
        'step-16': {skill:'perf',title:'Collision Snagging',prompt:"<p>QA reports one last bug: 'The Golem sometimes gets stuck on small bits of rubble on the ground.'</p><strong>What is the first and most direct thing to check to debug character movement snagging?</strong>",choices:[{text:'Select the Golem's <code>CapsuleComponent</code> in its Blueprint and check its size and position. Use the <code>p.ShowCollision</code> console command in-game to visualize it.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> A character's movement is almost always governed by its root capsule. Visualizing the collision in-game is the fastest way to confirm if it's too wide or low.</p>",next:'step-17'},{text:'Open the Golem's <code>Physics Asset</code> and simplify the collision bodies on its legs and feet.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This affects physical interactions, but the character's primary *movement* collision is the capsule. Check the capsule first.</p>",next:'step-17'},{text:'Increase the <code>Max Step Height</code> in the <code>Character Movement Component</code>.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This can help the character walk over small ledges, but doesn't solve the problem if the capsule is fundamentally too large.</p>",next:'step-17'},{text:'Increase the Golem's mass in its <code>Character Movement Component</code>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Mass affects physics pushback, not basic collision shape for walking.</p>",next:'step-17'}]},
        'step-17': {skill:'material',title:'Build Packaging Failure',prompt:"<p>The Golem is now working. You start the packaging process, but it fails with an error in the log: <code>Error: Found editor-only material expression DebugFloat3Values in /Game/Golems/Materials/M_Golem_Eye. Disallowed for cook.</code></p><strong>What does this mean?</strong>",choices:[{text:'A <code>debug node</code> was left in the eye material. These nodes are not allowed in packaged builds and must be removed.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The cooker strips out anything meant only for the editor. Leaving temporary <code>debug nodes</code> in the material graph causes this specific cook error.</p>",next:'step-18'},{text:'The material has a compile error that only shows up during cooking.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> It is a compile error, but the log message is very specific. It's not a general error, but one caused by a specific type of node.</p>",next:'step-18'},{text:'You need to install the <code>Material Debugging Utilities</code> plugin for the packaged game.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Debugging tools are explicitly meant for the editor only.</p>",next:'step-18'},{text:'The material needs to be saved with the <code>Shipping Build</code> flag enabled.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> No such flag exists for individual material assets.</p>",next:'step-18'}]},
        'step-18': {skill:'material',title:'Cleaning the Shader',prompt:"<p>You remove the offending <code>debug node</code> and re-save the material. You restart the packaging process. It fails again with a different, more general error regarding the Golem mesh.</p><strong>What common material error prevents a mesh from being included in a packaged build?</strong>",choices:[{text:'The <code>Collision Hull</code> for the mesh is missing or the <code>LODs</code> were imported incorrectly, causing a <code>static mesh validation error</code> during cook.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Complex meshes, especially <code>skeletal meshes</code>, must pass cook-time validation, which often fails due to missing <code>collision geometry</code> or malformed <code>LODs</code>.</p>",next:'conclusion'},{text:'The material is still using a <code>virtual texture asset</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> While <code>virtual textures</code> require proper setup, this is usually a separate warning, not a hard cook failure on a <code>static mesh component</code>.</p>",next:'conclusion'},{text:'You forgot to set the <code>Skeletal Mesh Component</code> to 'Hidden In Game'.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Hiding actors does not affect cook validation.</p>",next:'conclusion'},{text:'The issue is actually with the AnimBP, which must be compiled for the target platform.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> The error points to the mesh component itself, not the <code>AnimBP</code> logic.</p>",next:'conclusion'}]}
      }
  };