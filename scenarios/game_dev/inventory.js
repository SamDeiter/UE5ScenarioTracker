window.SCENARIOS['inventory'] = {
    meta: {
      title: "Inventory System: Data Corruption, Replication, and UI Scaling",
      description:
        "Players report item duplication on load, inventory lag, missing tooltips, and data struct replication failures. Covers Save Games, Replication, Data Tables, and UI efficiency.",
      estimateHours: 8.5,
        difficulty: "Intermediate",
        category: "UI" // Expanded estimate due to complexity
    },
    start: "step-1",
    steps:
	{
		'step-1': {skill:'data',title:'Missing Client Tooltips',prompt:"<p>An item has a correct <code>ItemID</code> (string), and the client calls <code>Get Data Table Row</code>. The server sees the details, but clients see blank tooltips.</p><strong>What is the most likely cause of this client-side failure?</strong>",choices:[{text:'Verify that the Data Table asset is included in the client's cooked build and is available at runtime.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Data assets are not automatically available on clients and must be explicitly cooked for distribution. Lookups will fail if the asset is missing.</p>",next:'step-2'},{text:'Move the lookup node to the Game Instance, as it runs on the server.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Moving it is a step toward centralization, but it doesn't fix the asset availability issue if it's not cooked for client deployment.</p>",next:'step-2'},{text:'Use a reliable RPC to send the ItemID to the server and Multicast the result back.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This assumes the asset *is* available but the logic is wrong. The core issue is the asset itself.</p>",next:'step-2'},{text:'Switch from string-based lookup to index-based lookup in the Data Table.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The column name is irrelevant; the asset itself is inaccessible.</p>",next:'step-1W'}]},
        'step-1W': {skill:'data',title:'Step 1B: Wasted Time on Key',prompt:"<p>You change the Data Table lookup to use an integer key, which fails just as badly. You realize the Data Table asset is simply missing on the client.</p><strong>What is the standard fix for ensuring a Data Asset is available in a client build?</strong>",choices:[{text:'Use the <strong>Project Settings -> Asset Manager</strong> to add the Data Table to the asset bundle rules for client builds.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> You must explicitly tell the cooker to include data assets required by the client runtime.</p>",next:'step-2'},{text:'Put the Data Table inside a custom plugin.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> While plugins are often cooked, this is an indirect method and not the intended way to manage asset availability.</p>",next:'step-2'}]},
		'step-2': {skill:'rep',title:'Delayed UI Update',prompt:"<p>The inventory array (<code>PlayerInventory</code>) is replicated. When the server adds an item, the client's UI updates, but it's delayed and sometimes misses updates.</p><strong>What is the most efficient, reliable, event-driven method for a client UI to respond immediately to an array change?</strong>",choices:[{text:'Change the <code>PlayerInventory</code> array's replication setting to <strong>'RepNotify'</strong> and bind the UI update logic to the <code>OnRep_PlayerInventory</code> function.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> RepNotify is the standard, optimized event that fires instantly on the client when a replicated variable is updated, ensuring immediate UI synchronization.</p>",next:'step-3'},{text:'Implement a Multicast RPC that fires after the array is changed, calling the UI update directly.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This updates current players instantly but fails to update late joiners, causing a state desync.</p>",next:'step-3'},{text:'Use Event Tick on the UI widget to constantly poll the character's inventory array.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Polling is inefficient and still introduces lag, leading to poor performance and delayed updates.</p>",next:'step-3'},{text:'Place the UI update logic in the <code>Event On Rep_PlayerState</code> function.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The inventory is typically on the character, not directly on the Player State, and this event may not cover the specific array change.</p>",next:'step-3'}]},
		'step-3': {skill:'save',title:'Item Duplication on Load',prompt:"<p>A player saves, quits, and loads. Their inventory list shows duplicated items. This is a consistent, reproducible bug.</p><strong>What is the likely cause of inventory duplication during load?</strong>",choices:[{text:'The <code>Load Game from Slot</code> logic is executed before the inventory array finishes its initial replication from the server, resulting in loaded data being added to an existing, non-empty array.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> This is a classic <strong>race condition</strong>. Load logic must be run on the server and only after the player's authoritative state variables are fully initialized.</p>",next:'step-4'},{text:'The items lack a unique ID, causing the load process to spawn new actors instead of restoring them.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Unique IDs are necessary, but the duplication is primarily a load order/timing issue, as the duplicated items are identical to the replicated ones.</p>",next:'step-4'},{text:'The save logic fails to clear the item count before saving the new state.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Saving is just writing the current state; it's the *loading* process that determines how data is merged.</p>",next:'step-4'},{text:'The Save Game object is corrupt and must be remade.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> The data structure itself is flawed, not the file integrity, as the bug is reproducible.</p>",next:'step-4'}]},
		'step-4': {skill:'save',title:'Load Order Logic (Server Hook)',prompt:"<p>You need a reliable server-side event to trigger the <code>Load Game</code> logic, ensuring it runs exactly once after the player's network state is stable.</p><strong>Which event on the Character/Pawn is the most robust place to initiate server-side post-load logic?</strong>",choices:[{text:'Use <code>Event Possessed</code> on the Pawn/Character, followed by a check for <code>Has Authority</code> to ensure server execution.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> <code>Event Possessed</code> fires reliably on the server after a Player Controller takes ownership, making it the perfect hook for authoritative load operations.</p>",next:'step-5'},{text:'Use <code>Event BeginPlay</code> on the Character with a <code>Is Locally Controlled</code> check.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> <code>BeginPlay</code> is too early, and <code>Is Locally Controlled</code> only confirms the machine is a client, not that it holds server authority.</p>",next:'step-5'},{text:'Use <code>Event Tick</code> on the Character, checking for a valid Player Controller.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Running load logic on <code>Event Tick</code> is extremely poor performance and will execute repeatedly.</p>",next:'step-5'},{text:'Call a custom event on the Game State, as the Game State persists across level loads.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> While the Game State persists, linking a player-specific load operation to a global state asset is overly complex compared to using the Pawn's own lifecycle events.</p>",next:'step-5'}]},
		'step-5': {skill:'data',title:'Item Property Corruption (SaveGame Specifier)',prompt:"<p>After saving and loading, item properties (like custom name, durability) are reset to default values, even though the inventory list structure is correct.</p><strong>What is the cause of this property reset failure in the UE Save Game system?</strong>",choices:[{text:'The properties within the item data Struct are missing the <code>UPROPERTY(SaveGame)</code> specifier in the native C++ code, preventing serialization.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The UE save system relies on reflection; properties must be explicitly tagged <code>SaveGame</code> to be written to the binary file and restored on load.</p>",next:'step-6'},{text:'The item Struct contains an array of structs, which the UE Save Game system cannot handle correctly.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> The standard system can handle arrays of primitives. The issue is usually the tagging of the properties, not the data type itself.</p>",next:'step-6'},{text:'The Save Game object is too large (over 1MB) and the file is truncated.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Truncation would break the structure, not just reset individual properties to their default values.</p>",next:'step-6'},{text:'The variable type (e.g., FString) is not supported for saving.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> FString is supported. The consistent reset points to the missing <code>SaveGame</code> tag.</p>",next:'step-6'}]},
        'step-6': {skill:'data',title:'Non-Persistent Unique IDs',prompt:"<p>Items need a unique ID that persists across save/load sessions. Currently, an integer counter is used, which resets on game exit.</p><strong>What is the standard alternative for generating a persistent, globally unique item identifier?</strong>",choices:[{text:'Implement the <strong><code>FGuid</code></strong> (Globally Unique Identifier) structure to generate unique IDs guaranteed to persist across sessions.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> FGuid generates a massive, virtually unique ID that is ideal for persistent instance identification.</p>",next:'step-7'},{text:'Store the integer counter in the Game Instance instead of the Player State.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This only solves the 'resetting' problem if the Game Instance is never rebuilt. It doesn't solve the global uniqueness problem in a multiplayer environment.</p>",next:'step-7'},{text:'Generate a random string using the <code>Random String</code> node when the item is created.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Random string generation is not cryptographically unique and is susceptible to collision over time in large projects.</p>",next:'step-7'},{text:'Use the item's <code>Object Name</code> as the unique ID.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Object names are editor-specific and can change at runtime (e.g., <code>_C_0</code>), making them highly unreliable for persistent identification.</p>",next:'step-7'}]},
        'step-7': {skill:'perf',title:'Inventory UI Hitching',prompt:"<p>When the player opens the inventory, the game hitches for a moment. Profiler points to <strong>Blocking I/O</strong> on the Game Thread.</p><strong>What common inventory action causes synchronous (blocking) I/O hitches?</strong>",choices:[{text:'A Data Table or asset is being loaded synchronously (blocking the game thread) to fetch item details or tooltips on inventory open.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Synchronous loading of assets (including Data Tables) on the Game Thread is the primary cause of single-frame hitches. This should be made asynchronous or cached.</p>",next:'step-8'},{text:'The UI widget is being created and populated entirely on one frame.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> UI rebuilding causes hitches but is usually attributed to heavy Slate/UMG costs, not disk I/O. The profiler explicitly noted Blocking I/O.</p>",next:'step-8'},{text:'Garbage Collection (GC) is running every time the inventory is opened.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> GC causes intermittent hitches, whereas blocking I/O is a repeatable, consistent hitch tied to the action (opening inventory).</p>",next:'step-8'},{text:'The game is trying to stream a sub-level during the inventory open event.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Level streaming is usually handled separately and wouldn't typically be triggered by an inventory open event.</p>",next:'step-8'}]},
        'step-8': {skill:'ui',title:'Widget Tick Inefficiency',prompt:"<p>You find that the inventory slots update their durability bar by calling a getter function on <code>Event Tick</code>, even if the item hasn't changed.</p><strong>What is the best way to optimize this to an event-driven system?</strong>",choices:[{text:'Use <strong>Event Dispatchers</strong> (called from the inventory RepNotify) to tell the specific item slot Widget exactly when its data has changed.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Event Dispatchers or explicit bindings eliminate the Tick overhead by only executing UI logic when a data change occurs. This is the correct event-driven approach.</p>",next:'step-9'},{text:'Set the Widget's Tick interval to 0.5 seconds instead of every frame.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is a band-aid, not a robust fix.</p>",next:'step-9'},{text:'Delete the getter function and write the durability value directly to the widget variable on Tick.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This still relies on <code>Event Tick</code> and adds unnecessary writes every frame.</p>",next:'step-9'},{text:'Enable the 'Is Volatile' flag on the durability bar widget.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The Is Volatile flag forces the widget to be redrawn every frame, making performance significantly worse.</p>",next:'step-9'}]},
        'step-9': {skill:'perf',title:'Save Game Hitch (I/O Block)',prompt:"<p>The system is clean, but calling <code>Save Game to Slot</code> causes a noticeable 1-second hang.</p><strong>What is the primary cause of hitching during large save operations, and what is the UE solution?</strong>",choices:[{text:'Cause: <code>Save Game to Slot</code> is a synchronous call blocking the Game Thread. Solution: Use the asynchronous node <strong><code>Async Save Game to Slot</code></strong>.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Asynchronous save delegates the heavy I/O and serialization work to a background thread, preventing the main game thread from stalling (hitching).</p>",next:'step-10'},{text:'Too many physics objects are being saved. Solution: Disable physics state saving for non-critical actors.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Reducing the amount of data helps, but the synchronous call is still the root cause of the hang.</p>",next:'step-10'},{text:'The save data is uncompressed. Solution: Enable binary compression.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Compression helps with file size but does not solve the synchronous I/O bottleneck.</p>",next:'step-10'},{text:'The hard drive is too slow. Solution: Advise the user to upgrade to an SSD.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Blaming the user/hardware for a predictable blocking call is not a professional solution.</p>",next:'step-10'}]},
        'step-10': {skill:'rep',title:'Structs Fail to Multicast',prompt:"<p>When multicasting a complex <code>ItemStruct</code> containing sub-properties, only the server sees the correct struct data; clients receive a blank struct.</p><strong>Why does a struct, when passed via an RPC, fail to serialize its contents to clients?</strong>",choices:[{text:'The primitive variables inside the Struct definition are missing the <strong><code>UPROPERTY(Replicated)</code></strong> specifier, preventing network serialization.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> For a complex type passed via an RPC, every sub-property must be explicitly marked for replication, even if the struct itself is not a replicated property.</p>",next:'step-11'},{text:'You cannot Multicast structs; you must split the struct into individual variables.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This solves the problem but is overly complex. Structs *can* be passed if their internal properties are correctly marked for replication.</p>",next:'step-11'},{text:'The Multicast RPC needs to be set to 'Reliable' instead of 'Unreliable'.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Reliability ensures the packet arrives, but it doesn't fix the core issue of a non-serialized payload.</p>",next:'step-11'},{text:'The <code>ItemStruct</code> is defined in Blueprints, which cannot be reliably replicated.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Blueprint-defined structs are fully supported for replication when properties are correctly marked.</p>",next:'step-11'}]},
        'step-11': {skill:'rep',title:'Array Replication Issue (Net Index)',prompt:"<p>You fix the Struct properties, but now the client's <code>PlayerInventory</code> array, which holds these structs, sometimes drops items or shows an item in the wrong slot.</p><strong>What is the most likely cause of desynchronization in large replicated arrays?</strong>",choices:[{text:'The engine's internal <strong>Net Index</strong> for the array is desynced. The array should be wrapped in a <strong>RepNotify</strong> function that runs array-specific validation logic.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> When complex array changes happen (insert/remove), the internal network indices can break. RepNotify on the array or using a <strong>Fast Array Serialization</strong> approach (C++) is needed.</p>",next:'step-12'},{text:'The array should be replicated as individual variables, not a single array.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is a simple fix for small arrays, but defeats the flexibility of the array structure.</p>",next:'step-12'},{text:'You must explicitly clear the client array before updating it from the server.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is a crude workaround that increases bandwidth and introduces visual stuttering.</p>",next:'step-12'},{text:'Increase the array capacity limit in the Project Settings.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Array capacity does not affect replication logic.</p>",next:'step-12'}]},
        'step-12': {skill:'ui',title:'Icon Image Corruption',prompt:"<p>The inventory is stable, but sometimes item icons appear as a white texture. The texture asset is valid.</p><strong>What is the most common reason a valid texture asset fails to render in a UI Widget?</strong>",choices:[{text:'The <strong>Texture's Compression Settings</strong> are incorrect, forcing a low-quality or unsupported format (e.g., normal map compression on a UI texture).',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> UI textures must often be set to <code>UserInterface2D</code> or <code>Default</code> compression to display correctly, especially with transparency, or they can be improperly cooked/decompressed.</p>",next:'step-13'},{text:'The image widget's Z-Order is too high/low.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This affects sorting, not the corrupted white appearance of the texture itself.</p>",next:'step-13'},{text:'The material instance applied to the image widget is using a Virtual Texture sampler.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Virtual Textures are primarily for terrain/megascan assets, not simple UI icons.</p>",next:'step-13'},{text:'You need to manually call <code>Force Load</code> on the texture asset on Event BeginPlay.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The asset manager should handle loading; manually forcing load is usually a waste of time.</p>",next:'step-13'}]},
        'step-13': {skill:'data',title:'Loot Drop Desync',prompt:"<p>When the server kills an enemy, a loot bag spawns. On the server, the loot bag contains 5 gold. On the client, it only shows 1 gold.</p><strong>What is the most common replication mistake for newly spawned, replicated actors like loot bags?</strong>",choices:[{text:'The loot bag's gold variable is replicated, but the spawning logic sets the value <strong>after</strong> the <code>Spawn Actor</code> node, causing the initial value to be missed by the client.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Replication happens during the actor's initialization. Values set *after* spawning must be handled via a <strong>RepNotify</strong> or explicitly set via a function called from the server immediately after spawn, like <strong>Expose on Spawn</strong>.</p>",next:'step-14'},{text:'The loot bag's gold value is not marked as <code>RepNotify</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> RepNotify is the fix, but the core issue is the <strong>timing</strong> of the variable assignment relative to the initial replication snapshot.</p>",next:'step-14'},{text:'The loot bag actor does not have its 'Replicates' flag checked.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> If replication was entirely off, the actor wouldn't appear on the client at all.</p>",next:'step-14'},{text:'The enemy that spawned the loot bag needs to Multicast the gold amount.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The spawned actor is responsible for replicating its own internal state, not the spawner.</p>",next:'step-14'}]},
        'step-14': {skill:'perf',title:'Over-Replicated Timer',prompt:"<p>You profile the game and notice the network bandwidth is unusually high. You trace it back to a system that tracks player health and armor using a <strong>RepNotify</strong> variable, which is updated every 0.1 seconds via a Timer Handle.</p><strong>What is the fundamental flaw in using a RepNotify variable tied to a high-frequency timer?</strong>",choices:[{text:'RepNotify is <strong>band-aid replication</strong> and should only be used when necessary. This variable should be a standard <strong>Replicated variable</strong> to let the engine's optimized property system handle updates.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> RepNotify forces a specific code path, which is less optimized than the engine's built-in property replication system, especially for frequently changing values.</p>",next:'step-15'},{text:'The timer interval should be increased to 0.5 seconds to reduce bandwidth.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Addresses the symptom (high bandwidth) but not the root cause (inefficient replication type).</p>",next:'step-15'},{text:'The variable should be converted to an <strong>RPC</strong> instead of a RepNotify.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> RPCs are for events, not continuous state updates, and would be even less efficient.</p>",next:'step-15'},{text:'The property needs to be converted to a <strong>Fast Array Serialization</strong> structure.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Fast Array Serialization is for arrays, not continuous single variables like health.</p>",next:'step-15'}]},
        'step-15': {skill:'ui',title:'Screen Resolution Scaling',prompt:"<p>The UI team reports that the inventory screen looks blurry on 4K monitors and is too large on smaller resolutions.</p><strong>What is the fundamental setting on the <strong>UMG Widget</strong> that must be adjusted for correct, resolution-independent scaling?</strong>",choices:[{text:'Change the <strong>Slot Widget</strong> property (e.g., Canvas Panel) from <strong>Fill Screen</strong> to <strong>Scale Box</strong> and set the appropriate size constraints.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The <strong>Scale Box</strong> and using <strong>Size Boxes</strong> for containers ensures the UI scales according to a defined ratio, preventing blurriness and improper cropping across resolutions.</p>",next:'step-16'},{text:'Manually calculate a scaling factor in the Graph based on <code>Get Viewport Size</code> and apply it to the Root Widget.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is a manual scripting solution that is brittle. The built-in UMG scaling tools are far superior.</p>",next:'step-16'},{text:'Increase the <strong>Draw Size</strong> of the entire UMG canvas.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Draw Size affects the render target size, which is unrelated to the scaling of the elements within the viewport.</p>",next:'step-16'},{text:'Enable the <strong>'Render at Fixed Resolution'</strong> option in Project Settings.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This forces the game to render at a low resolution and stretch, causing guaranteed blurriness.</p>",next:'step-16'}]},
        'step-16': {skill:'data',title:'Dynamic Struct Property Fail',prompt:"<p>A designer adds a new dynamic property to the <code>ItemStruct</code> (a boolean to track if the item is 'cursed'). They attempt to replicate this via the RepNotify array. Clients report the value is always false, even when the server sets it to true.</p><strong>Assuming the <code>ItemStruct</code> is correctly marked with <code>UPROPERTY(Replicated)</code>, what specific detail is still missing for this new property to work?</strong>",choices:[{text:'The new boolean property within the struct must also be explicitly marked as <strong><code>UPROPERTY(Replicated)</code></strong>.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Even if a struct containing properties is replicated, complex types often require *each field* within the struct to be explicitly marked for replication to ensure it's serialized and sent over the network.</p>",next:'step-17'},{text:'The designer needs to add a <strong>Net Index</strong> property to the struct.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Net Index is for arrays, not individual struct properties.</p>",next:'step-17'},{text:'The struct needs to be converted to a <strong>UObject</strong> instead of a struct.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> While UObjects replicate more easily, the cost in memory and complexity is high. The struct should work if properties are tagged correctly.</p>",next:'step-17'},{text:'The property name is misspelled in the replication function.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This is a guess; assume the code is correct first and check fundamental requirements.</p>",next:'step-17'}]},
        'step-17': {skill:'save',title:'Load Order/Dependency Failure',prompt:"<p>A new item spawning system requires loading item data before the player is possessed. If the load fails, the game should revert to a safe state.</p><strong>What is the safest place to run critical <strong>load-or-fail</strong> logic *before* the player pawn is spawned?</strong>",choices:[{text:'Run the logic on the <strong>GameMode</strong> (<code>PostLogin</code> or <code>PreInitializeComponents</code>) as it exists on the server before the player pawn.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The GameMode is server-only and exists at the start of the session, making it the authoritative place to handle initial load dependency checks before spawning the character.</p>",next:'step-18'},{text:'Run the logic on the <strong>GameInstance</strong> on <code>Event Init</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> GameInstance is client/server, but runs before the network is fully established and doesn't have authority.</p>",next:'step-18'},{text:'Run the logic on the <strong>PlayerState</strong> on <code>BeginPlay</code>.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> PlayerState spawns after GameMode and doesn't control the pawn spawning process.</p>",next:'step-18'},{text:'Use a level sequence to delay the entire game start.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This is an inelegant design-level hack that adds unnecessary complexity.</p>",next:'step-18'}]},
        'step-18': {skill:'perf',title:'High Bandwidth Spike (Unreliable Data)',prompt:"<p>You profile network performance and see huge bandwidth spikes when the player's inventory updates. This only happens when the item durability changes.</p><strong>If durability changes often, how should you replicate this single variable to reduce bandwidth without requiring a full RepNotify call?</strong>",choices:[{text:'Mark the durability variable as <strong><code>UPROPERTY(Reliable, Transient)</code></strong> and ensure it only replicates when its value actually changes, not every network tick.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> While <code>Transient</code> is not the whole answer, enabling default UE property replication is the efficient path. The engine handles the change delta better than manual logic.</p>",next:'step-19'},{text:'Only send the durability update via a custom, <strong>Unreliable RPC</strong> when the value is lower than 50%.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This works but is not guaranteed to arrive (unreliable) and requires manual logic to manage the threshold.</p>",next:'step-19'},{text:'Move the durability variable to the client side and hide it from the server.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Durability is a core game mechanic and must be server-authoritative. Moving it to the client side introduces cheating exploits.</p>",next:'step-19'},{text:'Increase the network update frequency of the actor to ensure faster delivery.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This *increases* bandwidth, which is the opposite of the goal.</p>",next:'step-19'}]},
        'step-19': {skill:'save',title:'Save File Corruption on Editor Crash',prompt:"<p>You crash the editor while the game is saving, and now the save file for Slot 1 is corrupted and unreadable, forcing users to delete it manually.</p><strong>What is the best practice for robust save game handling that protects against corruption?</strong>",choices:[{text:'Implement a <strong>'Save Buffer'</strong> strategy: Write the new file to a temporary slot, and only after success, rename the file to the final slot name.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The buffer strategy ensures that if the save operation fails mid-write, the original save file remains intact, preventing total data loss.</p>",next:'step-20'},{text:'Use the built-in <code>Backup</code> option on <code>Save Game to Slot</code>.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This creates a secondary backup, but the main file is still lost/corrupted if the operation fails mid-write.</p>",next:'step-20'},{text:'Store all save data in a Data Table instead of a binary Save Game object.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Data Tables are for static game data, not player progression/save data.</p>",next:'step-20'},{text:'Disable the autosave feature entirely.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Solves the corruption issue by eliminating the essential save feature.</p>",next:'step-20'}]},
        'step-20': {skill:'ui',title:'Editor vs. Runtime Text Difference',prompt:"<p>A designer adds new text to a UMG widget using the <strong>Text Block</strong> widget. It looks perfect in the UMG editor, but at runtime, the font spacing is incorrect, and certain characters are missing.</p><strong>What is the most likely cause of a font rendering difference between the editor and runtime?</strong>",choices:[{text:'The font asset is using <strong>Runtime Font Scaling</strong> or <strong>Composite Fonts</strong> which often break in cooked builds if not configured to embed all glyphs.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Fonts are complex. If the font isn't correctly set to embed the required glyphs or use the correct <code>Font Caching</code> method, it renders differently (or fails) in a packaged environment.</p>",next:'step-21'},{text:'The UMG widget's size constraint is being overridden by the parent container at runtime.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This affects size, not the font's appearance or missing characters.</p>",next:'step-21'},{text:'The font asset is corrupted and needs to be reimported.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This assumes asset failure, not configuration error.</p>",next:'step-21'},{text:'You need to set the <code>Text Block</code> to always update on Tick.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Tick updates the *value* of the text, not the rendering of the font itself.</p>",next:'step-21'}]},
        'step-21': {skill:'compile',title:'Final Compile/Cleanup',prompt:"<p>The inventory system is complete, robust, and performant. You do a final cleanup run before committing the changes.</p><strong>What is the ultimate, non-negotiable step before pushing code to a source control branch?</strong>",choices:[{text:'Run a full <strong>Project Build</strong> and <strong>Cook Content for Windows</strong> to check for cook errors, missing assets, or configuration failures.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Packaging is the final true test. A full cook reveals any remaining editor-only nodes, missing cross-references, or bad asset flags that PIE (Play in Editor) never catches. Milestone completed!</p>",next:'conclusion'},{text:'Delete all temporary 'Debug' files and folders from the Content Browser.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Good housekeeping, but doesn't guarantee the code works on another machine or in a final build.</p>",next:'conclusion'},{text:'Verify that all Blueprints are correctly connected to the primary Game Mode.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> That's a design check, not a functional or stability check.</p>",next:'conclusion'},{text:'Wait for the Continuous Integration (CI) server to run its build first.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Relying solely on CI introduces a delay and wastes build farm time; you should always pre-validate locally.</p>",next:'conclusion'}]}
	}
  };