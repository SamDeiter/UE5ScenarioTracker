window.SCENARIOS['world_partition'] = {
    meta: {
        expanded: true,
      title: "World Partition: LODs, Streaming, and Memory Spikes",
      description:
        "Large environment is failing to stream correctly, leading to massive hitches, incorrect LOD transitions, and high memory usage. Focuses on WP configuration, data layers, and distance fields.",
      estimateHours: 8.0,
        difficulty: "Advanced",
        category: "World" // Expanded estimate due to complexity
    },
    start: "step-inv-1",
    steps:
      {
        'step-1': {skill:'perf',title:'Game Thread Stutter',prompt:"<p>You launch the massive open world map. Every 30 seconds, the game freezes for 1-2 seconds. The profiler points to the <strong>Game Thread</strong> and <strong>Hitching</strong>.</p><strong>What is the primary cause of hitching in a large World Partition map?</strong>",choices:[{text:'The World Partition streaming system is synchronously loading large amounts of map data (Grid Streaming). Check the <strong>HLOD System</strong> setup.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Predictable hitching in a large world is typically the streaming system synchronously loading high-poly meshes because the HLOD setup is broken or missing.</p>",next:'step-2'},{text:'The garbage collector is running too frequently. Adjust the Garbage Collection settings in Project Settings.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> GC causes hitches, but interval-based hitching tied to movement/streaming is usually a World Partition/HLOD issue.</p>",next:'step-2'},{text:'The Post Process Volume's effects are too costly. Disable expensive features like Ray Tracing.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Rendering cost affects frame rate, not the Game Thread hitching associated with streaming.</p>",next:'step-2'},{text:'The player character's Tick function is too heavy. Investigate the Character Blueprint.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> A 1-2 second freeze is too severe to be a Character Tick issue.</p>",next:'step-2'}]},
        'step-2': {skill:'world',title:'Missing Distant Meshes',prompt:"<p>You check the HLOD settings and see they are enabled. But when you fly high above the landscape, all distant geometry (trees, rocks) disappears.</p><strong>What is the most likely configuration error in World Partition causing this?</strong>",choices:[{text:'The <strong>HLOD Layer</strong> asset for static meshes is missing from the HLOD setup or its settings incorrectly exclude actors beyond a short distance.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> HLOD layers generate the simplified proxy meshes for distant viewing. If they are misconfigured, distant geometry will simply vanish.</p>",next:'step-3'},{text:'The cull distance volume is too small. Increase the size of the Cull Distance Volume.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Cull Distance Volumes manually hide actors, but this problem affects *all* distant geometry, suggesting a core streaming/HLOD breakdown.</p>",next:'step-3'},{text:'The Material used by the distant meshes has 'Two Sided' disabled.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This would affect rendering on one side, not the complete disappearance of the mesh.</p>",next:'step-3'},{text:'The World Partition grid size is set too small, causing excessive streaming load.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Grid size affects *how frequently* data streams, not the absence of the data when streamed.</p>",next:'step-3'}]},
        'step-3': {skill:'world',title:'Incorrect LOD Transitions',prompt:"<p>You fix the HLOD Layer, but the transition from the HLOD mesh (proxy) to the high-poly mesh is jarring and visible around 50 meters away.</p><strong>How do you control the distance at which World Partition transitions from HLOD to high-poly data?</strong>",choices:[{text:'Adjust the <strong>Loading Range</strong> and <strong>Cell Size</strong> properties on the World Partition setup to synchronize the HLOD transition distance with the grid loading distance.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The loading range controls when the high-poly data streams in. Synchronizing this with the HLOD mesh visibility distance ensures a smooth transition.</p>",next:'step-4'},{text:'Modify the Level of Detail (LOD) settings on the individual static mesh assets.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This controls the LOD of the *high-poly mesh itself*, not the transition from the HLOD (proxy) mesh to the high-poly mesh.</p>",next:'step-4'},{text:'Change the material blend mode on the HLOD mesh to Translucent.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> A visual fix that will look wrong and introduces heavy overdraw performance issues.</p>",next:'step-4'},{text:'Increase the 'Tessellation Multiplier' on the Landscape Material.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Tessellation is unrelated to object streaming and LOD transitions.</p>",next:'step-4'}]},
        'step-4': {skill:'perf',title:'Renderer Hitching on Move',prompt:"<p>Movement is smooth when standing still, but rapid rotation or movement causes a severe spike in the <strong>Render Thread</strong> cost, briefly freezing the game.</p><strong>What common rendering feature, heavily reliant on distance fields, is causing this issue?</strong>",choices:[{text:'<strong>Global Distance Field</strong> generation is slow. Disable or optimize <strong>Distance Field Ambient Occlusion (DFAO)</strong> or <strong>Distance Field Shadows</strong>.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> DFAO and Distance Field Shadows constantly update the global distance field representation, causing render thread spikes during movement or camera changes.</p>",next:'step-5'},{text:'Nanite is causing excessive draw calls. Increase the Nanite Tesselation setting.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Nanite is highly performant and shouldn't cause render thread spikes unless its visibility culling is completely broken. This is a misguided optimization.</p>",next:'step-5'},{text:'The Post Process Volume's Motion Blur is set too high. Reduce the intensity.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Motion blur affects the final image but doesn't cause severe render thread spikes related to geometry movement/distance fields.</p>",next:'step-5'},{text:'The Texture Streaming Pool is too small. Increase the budget in Project Settings.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Texture streaming issues result in low-resolution textures, not render thread spikes.</p>",next:'step-5'}]},
        'step-5': {skill:'lighting',title:'Black/Missing Shadows',prompt:"<p>The distant fields are disabled for now. But now, all the static meshes have missing or incorrect shadows after a lighting rebuild.</p><strong>What is the primary check for static mesh shadow setup?</strong>",choices:[{text:'Ensure the <strong>Directional Light</strong> has <strong>Cast Shadows</strong> enabled and that the mesh has a valid <strong>Lightmap UV</strong> channel.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Static lighting relies entirely on the lightmap UV channel (usually UV Channel 1) and the light's shadow casting setting. Both must be correct for baked shadows to work.</p>",next:'step-6'},{text:'Increase the bounds of the Lightmass Importance Volume to encompass the area.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This affects *quality*, but if the mesh has no lightmap UVs or the light isn't casting, it won't help.</p>",next:'step-6'},{text:'Change the light's mobility from Stationary to Movable.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This switches to dynamic shadows, increasing performance cost, and doesn't fix issues with the intended baked static shadow setup.</p>",next:'step-6'},{text:'The shadow map resolution is too low. Increase the setting on the mesh.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Low resolution results in blocky shadows, not missing ones.</p>",next:'step-6'}]},
        'step-6': {skill:'world',title:'Data Layer Desync',prompt:"<p>A new cinematic team asset, <code>BP_CinematicGate</code>, is set to only appear when the player enters a <code>DataLayer_Cinematic</code>. But the gate is visible all the time, even when the data layer is inactive.</p><strong>How do you fix this Data Layer synchronization issue?</strong>",choices:[{text:'Ensure the <strong>Data Layer Asset</strong> is properly assigned to the <strong>Actor</strong> and that the <strong>Data Layer Runtime</strong> plugin is enabled and set up to stream layers.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Data layers are only functional at runtime if the Data Layer Runtime plugin is active and the layer visibility is being managed by a Level Streaming Volume or code.</p>",next:'step-7'},{text:'Set the actor's visibility property to 'Hidden In Game' in the Details panel.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This hides it, but defeats the purpose of the data layer system, which is meant for streaming dynamic content.</p>",next:'step-7'},{text:'Use Event BeginPlay to manually check the Data Layer status and hide/show the gate.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is manual and error-prone. The engine's streaming system should handle this automatically when configured correctly.</p>",next:'step-7'},{text:'Move the gate actor to a completely different sub-level.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> World Partition replaces the sub-level system; moving the actor wouldn't fix the layer association.</p>",next:'step-7'}]},
        'step-7': {skill:'world',title:'Forcing a Player Start',prompt:"<p>You try to test a multiplayer scenario, but the client pawn is spawning at the world origin (0,0,0) instead of the <strong>PlayerStart</strong> you placed.</p><strong>Why is the client ignoring the PlayerStart in a World Partition map?</strong>",choices:[{text:'The PlayerStart actor is not configured with the correct <strong>Data Layer</strong> (e.g., Default or Runtime) and is not being streamed in when the client spawns.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> In World Partition, if the PlayerStart isn't in a streamed-in cell/layer, the game can't find it and defaults to (0,0,0). Assign it to a layer that streams immediately.</p>",next:'step-8'},{text:'The Game Mode is corrupted and needs to be replaced.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> The Game Mode handles spawning, but the failure to find the spawn point is a World Partition/streaming issue.</p>",next:'step-8'},{text:'The client must manually teleport to the PlayerStart after spawning.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is a brittle workaround for a fundamental setup error.</p>",next:'step-8'},{text:'You must disable the World Partition feature in Project Settings.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Disabling WP is too extreme; the solution is in proper actor placement/layering.</p>",next:'step-8'}]},
        'step-8': {skill:'lighting',title:'Landscape Shadow Artifacts',prompt:"<p>The player starts correctly. When moving across the landscape, large, blocky shadow artifacts appear and disappear dynamically on the terrain.</p><strong>What setting primarily controls the quality and resolution of dynamic shadows on the Landscape?</strong>",choices:[{text:'The <strong>Dynamic Shadow Resolution</strong> or <strong>Shadow Bias</strong> settings on the <strong>Directional Light</strong> are too low/high, creating cascading artifacts on the far geometry.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Dynamic shadows are controlled by the light source. Adjusting resolution or bias is necessary to trade quality for performance and eliminate artifacts.</p>",next:'step-9'},{text:'The landscape has too many sections. Reduce the number of landscape components.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This helps performance but doesn't directly fix the visual quality of the shadow maps being rendered.</p>",next:'step-9'},{text:'Increase the <strong>Lightmap Resolution</strong> of the landscape.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Lightmap resolution is for *baked* static shadows, not the dynamic shadows seen here.</p>",next:'step-9'},{text:'The distance field generation quality needs to be increased.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> If DFAO/DFS is off (Step 4), this setting is irrelevant. If on, it relates to AO/DFS, not general dynamic shadow resolution.</p>",next:'step-9'}]},
        'step-9': {skill:'perf',title:'High Draw Calls (Non-Nanite)',prompt:"<p>The level is performing well, but a specific structure, <code>SM_AncientBridge</code>, is causing high draw calls when the camera is close to it. The bridge is <strong>not</strong> Nanite-enabled.</p><strong>What optimization should you perform on this non-Nanite mesh to reduce its draw calls?</strong>",choices:[{text:'<strong>Merge</strong> the bridge's multiple static mesh components into a single mesh and reduce its <strong>Material Slots</strong> to one.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Every material slot on a non-instanced mesh is a separate draw call. Merging geometry and materials is the most effective pre-Nanite optimization.</p>",next:'step-10'},{text:'Enable <strong>Nanite</strong> on the mesh. It's the modern solution.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> While correct, the ticket specifies a non-Nanite optimization path (perhaps due to platform restrictions). The answer should address the core draw call mechanic.</p>",next:'step-10'},{text:'Decrease the <strong>Screen Size</strong> threshold on its default LOD to make it transition faster.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> LODs reduce triangle count, not the base number of draw calls generated by material slots.</p>",next:'step-10'},{text:'Add the mesh to a <strong>Level Streaming Volume</strong>.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Streaming handles visibility at a distance; it doesn't optimize draw calls when the mesh is already visible.</p>",next:'step-10'}]},
        'step-10': {skill:'world',title:'Seamless Travel Failure',prompt:"<p>You try to trigger a <strong>Seamless Travel</strong> to a new map. The server successfully loads the map, but clients are immediately dropped back to the main menu instead of joining the new world.</p><strong>What flag must be set on the Game Mode or Server to allow clients to join a new map mid-game?</strong>",choices:[{text:'The <strong>Game Mode</strong> must have the <strong>bUseSeamlessTravel</strong> flag set to <code>True</code>.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Seamless Travel requires this flag to be set to ensure clients are correctly preserved and moved to the new server map instance instead of being forcefully disconnected.</p>",next:'step-11'},{text:'The server must run a <code>Multicast RPC</code> to tell clients to open the new level.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This is part of the process, but the clients being *dropped* specifically indicates the server is not preserving their connection state, which the flag fixes.</p>",next:'step-11'},{text:'The new map must be added to the list of <code>Maps to Cook</code> in Project Settings.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This is necessary for packaging, but irrelevant for PIE or a running dedicated server session.</p>",next:'step-11'},{text:'All World Partition cells must be fully streamed in before calling ServerTravel.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> While ideal, this is not the cause of the client drop/disconnection failure.</p>",next:'step-11'}]},
        'step-11': {skill:'world',title:'Travel Between Data Layers',prompt:"<p>Seamless Travel is now fixed. You realize the new map uses a different set of <strong>Data Layers</strong> for initial streaming than the old map.</p><strong>What is the best way to ensure the *correct* set of Data Layers streams in immediately upon the client joining the new map?</strong>",choices:[{text:'The Game Mode (or the logic triggering the travel) must call <code>ServerTravel</code> with the specific <strong>Data Layer</strong> names included in the URL options.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The standard way to control which layers stream immediately is by appending <code>?DataLayers=LayerA,LayerB</code> to the <code>ServerTravel</code> command or URL, overriding defaults.</p>",next:'step-12'},{text:'On the new map, manually stream in the required layers on Event BeginPlay.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This runs on the client but risks timing issues. Using the travel URL ensures the layers are correctly queued by the networking system.</p>",next:'step-12'},{text:'Disable Data Layers entirely for the new map.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This defeats the purpose of the feature and forces the entire map to load, breaking performance.</p>",next:'step-12'},{text:'Ensure the World Settings file for the new map is marked as 'Always Loaded'.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> The World Settings asset is always loaded, but its contained Data Layers still require explicit streaming configuration.</p>",next:'step-12'}]},
        'step-12': {skill:'perf',title:'The Final Memory Crash',prompt:"<p>Everything is stable, but a final QA report shows a <strong>Memory Crash</strong> after 3 hours of play, primarily on the client. The crash log points to a memory spike in the <strong>Static Mesh Component</strong> loading.</p><strong>What specific memory optimization is critical to perform on the map assets to prevent this long-term memory spike?</strong>",choices:[{text:'Enable <strong>Nanite</strong> on all high-poly static meshes. This reduces mesh data memory consumption and dramatically improves rendering performance.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Nanite intelligently streams only necessary geometry data, preventing large, high-poly static meshes from saturating client memory over time.</p>",next:'step-13'},{text:'Reduce the size of the Texture Streaming Pool to lower GPU memory usage.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This helps GPU memory (VRAM), but the crash log pointed to *Static Mesh Component* memory, which is primarily CPU memory (RAM) used for geometry data.</p>",next:'step-13'},{text:'Increase the frequency of Garbage Collection runs.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> GC cleans up dynamic memory (objects), not the persistent memory footprint of loaded static mesh data.</p>",next:'step-13'},{text:'Convert all static meshes to Instanced Static Mesh Components (ISMCs).',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> ISMCs help draw call performance, but the geometry data for the original mesh is still loaded, thus failing to solve the memory footprint issue.</p>",next:'step-13'}]},
        'step-13': {skill:'world',title:'World Bounds Collision Failure',prompt:"<p>The player can still walk far past the intended edge of the map, even though a <strong>World Bounds Volume</strong> has been placed.</p><strong>What is the most likely reason the World Bounds Volume is failing to prevent player exit?</strong>",choices:[{text:'The <strong>Kill Z</strong> or <strong>World Bounds</strong> logic is part of the <code>Game Mode</code> or <code>Player Controller</code> and must be correctly implemented to enforce the boundary rules.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The volume simply defines the limit; the game logic must be present to detect if the player is outside the volume and apply the consequence (e.g., teleport, death).</p>",next:'step-14'},{text:'The World Bounds Volume has its collision preset set to IgnoreAll.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> It requires collision, but the problem is the missing *logic* to act on that collision.</p>",next:'step-14'},{text:'The player character is ignoring the World Bounds trace channel.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Unrelated to the World Bounds Volume itself.</p>",next:'step-14'},{text:'The volume must be set to Movable mobility.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Mobility is irrelevant for this purpose.</p>",next:'step-14'}]},
        'step-14': {skill:'lighting',title:'Sky Light Bleeding',prompt:"<p>You find that a small, enclosed cave still has faint ambient light leaking in, even though it's fully sealed.</p><strong>What is the primary source of global ambient light in the scene, and how do you exclude it from specific indoor areas?</strong>",choices:[{text:'The <strong>Sky Light</strong> is the source. Place a <strong>Post Process Volume</strong> inside the cave and adjust its <strong>Sky Light Multiplier</strong> to zero, ensuring it affects only the interior.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The Sky Light simulates ambient sky light. Overriding its intensity with a local Post Process Volume is the standard way to darken interiors.</p>",next:'step-15'},{text:'Increase the lightmass portals on the cave entrance.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Lightmass Portals only improve baked lighting quality; they don't stop dynamic/Lumen global light.</p>",next:'step-15'},{text:'Build a custom static mesh blocker around the exterior of the cave.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Crude solution that adds geometry complexity unnecessarily.</p>",next:'step-15'},{text:'Delete the Sky Light from the level.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This fixes the cave but breaks the entire outdoor lighting environment.</p>",next:'step-15'}]},
        'step-15': {skill:'world',title:'Streaming Logic on Dedicated Server',prompt:"<p>You find a Blueprint that manually forces a World Partition cell to stream in on <code>Event Tick</code> for all actors within a certain radius. This works on client/listen servers but fails on a dedicated server.</p><strong>Why would this manual streaming logic fail on a dedicated server?</strong>",choices:[{text:'A Dedicated Server typically <strong>does not stream</strong> World Partition cells because it has no camera/viewpoint to manage visibility for clients.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Dedicated servers often load the entire map or only essential cells, as their primary job is logic, not rendering/streaming. Manual streaming logic based on distance often breaks here.</p>",next:'step-16'},{text:'The dedicated server requires a different streaming flag in Project Settings.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> It uses the same flags, but the core execution path is different.</p>",next:'step-16'},{text:'The Blueprint is missing a <code>Has Authority</code> check.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Authority is present, but the underlying streaming function relies on a client/rendering context that the dedicated server lacks.</p>",next:'step-16'},{text:'Dedicated servers only stream if the player is physically standing there.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Dedicated servers do not have player camera positions for streaming logic.</p>",next:'step-16'}]},
        'step-16': {skill:'world',title:'Dynamic Actor Despawn',prompt:"<p>You convert a complex dynamic enemy spawner to use <strong>World Partition Data Layers</strong>. The spawner is set to unload when the player leaves the area, but the enemies spawned by it remain in the world, causing performance drag.</p><strong>What is needed to ensure dynamically spawned actors are also cleaned up when their spawner's cell unloads?</strong>",choices:[{text:'The dynamically spawned actors must be manually assigned to the same <strong>Data Layer</strong> as their parent spawner when they are created.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Actors spawned at runtime do not automatically inherit the layer. You must explicitly set their layer to ensure they are tracked and unloaded by the World Partition system.</p>",next:'step-17'},{text:'The spawner actor needs to call <code>Destroy Actor</code> on its children before its own Unload event runs.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> This works, but is a manual solution that is less reliable than letting the World Partition system handle the lifecycle.</p>",next:'step-17'},{text:'You must disable the World Partition grid system and use standard <strong>Level Streaming Volumes</strong> instead.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Too extreme; the system supports dynamic actors if properly layered.</p>",next:'step-17'},{text:'The spawned enemies must be set to <code>Replicates</code> = False.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> This would remove them from clients, but they would remain on the server, still causing game thread lag.</p>",next:'step-17'}]},
        'step-17': {skill:'perf',title:'Final Cleanup - Unused Asset Bloat',prompt:"<p>The lead asks you to check the final build size. It's 20GB larger than expected. You check the Cooked Content folder and see many unused <strong>Texture and Sound assets</strong>.</p><strong>What is the standard, systematic way to prevent unused assets from being included in the final packaged build?</strong>",choices:[{text:'Use the <strong>Reference Viewer</strong> and <strong>Fix Up Redirectors in Folder</strong> to clean up and ensure no assets are accidentally referenced by temporary editor assets.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Asset management starts with identifying unnecessary references. The Reference Viewer and Redirector cleanup is the primary tool for this.</p>",next:'step-18'},{text:'Manually delete all assets that aren't currently placed in the level.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Dangerous! You risk deleting assets referenced only by Blueprints or Data Tables that aren't placed in the map.</p>",next:'step-18'},{text:'Increase the 'Texture Streaming Pool' to handle the extra data.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> This addresses symptoms (memory) not the root cause (bloat). You are just throwing more memory at an inefficiency.</p>",next:'step-18'},{text:'Use the <code>Disable Asset Cooking</code> flag on all folders with unused assets.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> No such blanket flag exists for cooking; you must fix the references.</p>",next:'step-18'}]},
        'step-18': {skill:'compile',title:'Final C++ Compiler Warning',prompt:"<p>After compiling the C++ code for packaging, you see a warning: <code>Warning: Member variable 'MyCharacter::Health' not initialized in constructor.</code></p><strong>Why is this warning critical for game stability, especially with replication?</strong>",choices:[{text:'Uninitialized member variables can hold arbitrary memory values (garbage data) which can lead to unpredictable behavior or security issues in shipping builds.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Initialization is a C++ fundamental. Garbage data can break replication and cause unpredictable bugs that are nearly impossible to trace.</p>",next:'step-19'},{text:'The variable will not replicate if it is not initialized.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> It *can* replicate, but its initial value will be unpredictable garbage, which is the problem.</p>",next:'step-19'},{text:'The warning only appears if the code is set to debug mode.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> Compiler warnings appear based on compiler settings, often for release builds to enforce stability.</p>",next:'step-19'},{text:'It means the Blueprint exposed variable must be set to 'Instance Editable'.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Unrelated to C++ initialization fundamentals.</p>",next:'step-19'}]},
        'step-19': {skill:'perf',title:'CPU Load Spike (Tick Dependency)',prompt:"<p>You see a massive spike in CPU load on the Game Thread. You trace it to an <strong>Event Tick</strong> loop that calls <code>GetAllActorsOfClass</code> every frame to check for nearby enemies.</p><strong>What is the proper, scalable alternative to iterating over all actors on Tick?</strong>",choices:[{text:'Use <strong>Sphere/Box Overlap</strong> checks or <strong>Environment Query System (EQS)</strong> to find enemies, which are frame-optimized and don't iterate the entire world array.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> Iterating over all actors on Tick is a Game Thread killer. Overlap checks and EQS are highly optimized native solutions.</p>",next:'step-20'},{text:'Convert the Tick function to a <strong>Timer Handle</strong> running at 0.5-second intervals.',type:'partial',feedback:'<p><strong>Standard Time Logged:</strong> Reduces frequency but doesn't eliminate the cost of the <code>GetAllActorsOfClass</code> call when it *does* run.</p>",next:'step-20'},{text:'Enable <strong>Instanced Static Mesh Components (ISMCs)</strong> on the spawner.',type:'misguided',feedback:'<p><strong>Extended Time Logged (Investigation):</strong> ISMCs are for rendering optimization, irrelevant to game logic performance.</p>",next:'step-20'},{text:'Change the network update frequency of the actor.',type:'wrong',feedback:'<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Network update frequency affects replication, not local Game Thread CPU cost.</p>",next:'step-20'}]},
        'step-20': {skill:'compile',title:'Final Package Success',prompt:"<p>The world is optimized, bugs are fixed, and the final cook has no errors.</p><strong>What is the next immediate step for deployment?</strong>",choices:[{text:'Commit all changes to the main development branch and tag the successful milestone for deployment to QA/Staging.',type:'correct',feedback:'<p><strong>Optimal Time Logged:</strong> The work is done; ensuring the changes are committed and the stable build is tagged for the next stage is the final step in the development cycle. Milestone completed!</p>",next: 'step-inv-1",
        'step-inv-1': {
            skill: 'world',
            title: 'Investigation 1: Confirming World Partition Activation',
            prompt: "<p>Before profiling, you must confirm the map is correctly using World Partition. What is the fastest way to verify that World Partition is active and the map is partitioned?</p>",
            choices: [
                {
                    text: "Check the <strong>World Settings</strong> panel for the World Partition setup and ensure the map file is a <code>.umap</code> (not a legacy <code>.level</code> file).",
                    type: 'correct',
                    feedback: "<p><strong>Optimal Time Logged:</strong> World Partition settings are centralized in World Settings. If the map is still using legacy streaming, the entire debugging path is incorrect.</p>",
                    next: 'step-inv-2'
                },
                {
                    text: "Check the Project Settings under 'Maps & Modes' to ensure World Partition is enabled globally.",
                    type: 'partial',
                    feedback: "<p><strong>Standard Time Logged:</strong> While necessary, the World Settings panel confirms the current map is using the feature.</p>",
                    next: 'step-inv-2'
                },
                {
                    text: "Look for Level Streaming Volumes in the map.",
                    type: 'wrong',
                    feedback: "<p><strong>Maximum Time Logged (Ineffective Fix):</strong> World Partition replaces Level Streaming Volumes.</p>",
                    next: 'step-inv-2'
                },
            ]
        },

        'step-inv-2': {
            skill: 'perf',
            title: 'Investigation 2: Visualizing Streaming Load',
            prompt: "<p>The hitching is predictable. To confirm it's streaming related, what console command should you use to visualize the loading status of World Partition cells in real-time?</p>",
            choices: [
                {
                    text: "Use the console command <code>r.WorldPartition.ShowStreaming 1</code> to visualize the grid cells and their loading states (Loaded, Unloaded, Loading).",
                    type: 'correct',
                    feedback: "<p><strong>Optimal Time Logged:</strong> This visualization immediately shows if the system is attempting to load cells synchronously (the cause of the hitch) or if cells are failing to load.</p>",
                    next: 'step-inv-1'
                },
                {
                    text: "Use <code>stat streaming</code> to check the texture streaming pool size.",
                    type: 'partial',
                    feedback: "<p><strong>Standard Time Logged:</strong> Useful for texture issues, but the visualization command is better for diagnosing geometry/cell streaming issues.</p>",
                    next: 'step-inv-1'
                },
                {
                    text: "Use <code>stat unit</code> to check the Game Thread time.",
                    type: 'misguided',
                    feedback: "<p><strong>Extended Time Logged (Investigation):</strong> This confirms the hitch is on the Game Thread, but doesn't show *why* the streaming system is failing.</p>",
                    next: 'step-inv-1'
                },
            ]
        },

        'step-rh-1': {
            skill: 'lighting',
            title: 'Red Herring: GPU Visualization Confusion',
            prompt: "<p>You switch to the 'Shader Complexity' view mode and see large areas of red (high complexity). You spend time optimizing materials, but the Render Thread spike from Step 4 persists.</p><strong>Why did optimizing shader complexity fail to fix the Render Thread spike caused by movement?</strong>",
            choices: [
                {
                    text: "Shader complexity affects pixel shading cost (GPU), while the movement spike was caused by Distance Field generation/updates, which is a Render Thread (CPU side of rendering) bottleneck.",
                    type: 'correct',
                    feedback: "<p><strong>Optimal Time Logged:</strong> It's crucial to distinguish between GPU (pixel shading) cost and Render Thread (CPU submission/setup) cost. Distance Field updates are Render Thread heavy.</p>",
                    next: 'step-rh-1'
                },
                {
                    text: "The shader complexity view mode is only accurate for static meshes, not landscape materials.",
                    type: 'partial',
                    feedback: "<p><strong>Standard Time Logged:</strong> While landscape complexity can be high, the core issue is the confusion between GPU and Render Thread bottlenecks.</p>",
                    next: 'step-rh-1'
                },
                {
                    text: "The materials were already compiled, so the optimization didn't take effect.",
                    type: 'wrong',
                    feedback: "<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Material changes take effect immediately upon saving/recompiling.</p>",
                    next: 'step-rh-1'
                },
            ]
        },

        'step-ver-1': {
            skill: 'world',
            title: 'Verification 1: Streaming Stability Stress Test',
            prompt: "<p>To confirm the HLOD and streaming fixes (Steps 1-3) are robust, you need to stress test the system.</p><strong>What is the most effective way to force rapid cell loading and unloading?</strong>",
            choices: [
                {
                    text: "Use the <code>stat streaming</code> command while rapidly flying the camera across the map boundary at high speed, observing the Game Thread time and the streaming pool usage.",
                    type: 'correct',
                    feedback: "<p><strong>Optimal Time Logged:</strong> Rapid movement forces the streaming system to load and unload cells aggressively. Monitoring <code>stat streaming</code> confirms the system handles the load asynchronously without hitching.</p>",
                    next: 'step-ver-2'
                },
                {
                    text: "Run the game in a dedicated server mode.",
                    type: 'partial',
                    feedback: "<p><strong>Standard Time Logged:</strong> Dedicated servers often load the entire map, which defeats the purpose of testing the streaming system under stress.</p>",
                    next: 'step-ver-2'
                },
                {
                    text: "Use the console command <code>t.MaxFPS 10</code> to slow down the game and observe the loading process.",
                    type: 'wrong',
                    feedback: "<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Slowing the game down prevents the stress test needed to verify stability.</p>",
                    next: 'step-ver-2'
                },
            ]
        },

        'step-ver-2': {
            skill: 'perf',
            title: 'Verification 2: Final Performance Baseline',
            prompt: "<p>The final step is to ensure the performance metrics are stable in a packaged environment, which often differs from PIE.</p><strong>How do you capture the final, accurate performance baseline?</strong>",
            choices: [
                {
                    text: "Run the game in a <strong>Standalone Game</strong> instance or a packaged build and use the <code>stat unit</code> and <code>stat gpu</code> commands to confirm stable frame times and memory usage.",
                    type: 'correct',
                    feedback: "<p><strong>Optimal Time Logged:</strong> Standalone mode is the closest environment to a shipping build, providing the most accurate performance metrics free from editor overhead.</p>",
                    next: 'conclusion'
                },
                {
                    text: "Use the in-editor profiler (Unreal Insights) while running PIE.",
                    type: 'partial',
                    feedback: "<p><strong>Standard Time Logged:</strong> Useful, but PIE includes editor overhead which can skew the final performance numbers.</p>",
                    next: 'conclusion'
                },
                {
                    text: "Check the memory usage in the Windows Task Manager.",
                    type: 'misguided',
                    feedback: "<p><strong>Extended Time Logged (Investigation):</strong> Task Manager is too coarse; you need engine-specific stats like <code>stat unit</code> and <code>stat memory</code> for accurate diagnosis.</p>",
                    next: 'conclusion'
                },
            ]
        },

        'conclusion'},{text:'Delete the local save game data.',type:'partial',feedback:"<p><strong>Standard Time Logged:</strong> Good habit, but not the priority after a successful package.</p>",next: 'step-inv-1",





        'conclusion'},{text:'Restart the editor to ensure all temporary files are cleared.',type:'misguided',feedback:"<p><strong>Extended Time Logged (Investigation):</strong> Unnecessary after a clean cook.</p>",next: 'step-inv-1",





        'conclusion'},{text:'Start working on the next ticket immediately.',type:'wrong',feedback:"<p><strong>Maximum Time Logged (Ineffective Fix):</strong> Documentation and committing the current work is the immediate priority.</p>",next: 'step-inv-1",





        'conclusion'}]}
      }
  };